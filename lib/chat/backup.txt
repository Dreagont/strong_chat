import 'dart:async';
import 'dart:io';

import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:strong_chat/services/AuthService.dart';
import 'package:strong_chat/services/FireStoreService.dart';
import 'package:intl/intl.dart';
import 'package:url_launcher/url_launcher.dart';

import '../services/StorageService.dart';
import '../utils/Utils.dart';
import 'ChatUtils/ImageWithPlaceholder.dart';
import 'ChatUtils/MessageSenderService.dart';
import 'ChatUtils/UserInput.dart';
import 'Media/VideoPlayerWidget.dart';

class ChatPage extends StatefulWidget {
  final String friendName;
  final String friendId;
  final String nickname;

  const ChatPage(
      {super.key,
      required this.friendName,
      required this.friendId,
      required this.nickname});

  @override
  _ChatPageState createState() => _ChatPageState();
}

class _ChatPageState extends State<ChatPage> {
  final TextEditingController messController = TextEditingController();
  final FireStoreService chatService = FireStoreService();
  final AuthService authService = AuthService();
  final StorageService storageService = StorageService();
  late final MessageSenderService messageSender;
  FocusNode focusNode = FocusNode();
  ScrollController scrollController = ScrollController();

  List<Map<String, dynamic>> allMessages = [];
  List<Map<String, dynamic>> displayedMessages = [];

  static const int messagesPerPage = 14;
  bool isLoadingMore = false;
  StreamSubscription? _messageSubscription;
  bool isBlocked = false;

  @override
  void initState() {
    super.initState();
    messageSender = MessageSenderService(
      chatService: chatService,
      authService: authService,
      storageService: storageService,
      friendId: widget.friendId,
      onMessageAdded: _handleMessageAdded,
      onMessageSent: goToBot,
    );

    scrollController.addListener(_scrollListener);
    _setupMessageStream();
    _setupBlockedStream();

    focusNode.addListener(() {
      if (focusNode.hasFocus) {
        Future.delayed(const Duration(milliseconds: 500), () => goToBot());
      }
    });
  }

  void _setupBlockedStream() {
    final userId = authService.getCurrentUserId();
    chatService.getIsBlockedStream(userId, widget.friendId).listen((blocked) {
      setState(() {
        isBlocked = blocked;
      });
    });
  }

  void _setupMessageStream() {
    final userId = authService.getCurrentUserId();
    _messageSubscription =
        chatService.getMessage(userId, widget.friendId).listen((snapshot) {
      if (snapshot.docs.isNotEmpty) {
        setState(() {
          allMessages = snapshot.docs.map((doc) {

            Map<String, dynamic> data = doc.data() as Map<String, dynamic>;
            return {
              'id': doc.id,
              'message': data['message'],
              'messType': data['messType'],
              'timeStamp': data['timeStamp'],
              'senderId': data['senderId'],
              'fileName': data['fileName'],
              'isNoti_isDeliver': data['isNoti_isDeliver'],
              'isRead': data['isRead'],
              'likes': List<String>.from(data['likes'] ?? []),
              'deletedBy': List<String>.from(data['deletedBy'] ?? []),
            };
          }).toList();


          allMessages.sort((a, b) => (b['timeStamp'] as Timestamp)
              .compareTo(a['timeStamp'] as Timestamp));

          if (displayedMessages.isEmpty) {
            displayedMessages = allMessages.take(messagesPerPage).toList();
          } else {
            var newMessages = allMessages
                .take(messagesPerPage)
                .where((message) => !displayedMessages.any((displayed) =>
                    displayed['timeStamp'] == message['timeStamp'] &&
                    displayed['message'] == message['message']))
                .toList();

            if (newMessages.isNotEmpty) {
              displayedMessages = allMessages.take(messagesPerPage).toList();
            }
          }
        });
      }
    });
  }

  void _scrollListener() {
    if (scrollController.hasClients &&
        scrollController.position.pixels >=
            scrollController.position.maxScrollExtent &&
        !isLoadingMore &&
        displayedMessages.length < allMessages.length) {
      _loadMoreMessages();
    }
  }

  void _loadMoreMessages() async {
    if (isLoadingMore || displayedMessages.length >= allMessages.length) return;

    setState(() {
      isLoadingMore = true;
    });

    final currentScrollPosition = scrollController.position.pixels;

    await Future.delayed(Duration(milliseconds: 500));

    setState(() {
      int startIndex = displayedMessages.length;
      int endIndex = startIndex + messagesPerPage;
      if (endIndex > allMessages.length) {
        endIndex = allMessages.length;
      }

      displayedMessages.addAll(allMessages.sublist(startIndex, endIndex));
      isLoadingMore = false;
    });

    WidgetsBinding.instance.addPostFrameCallback((_) {
      if (scrollController.hasClients) {
        scrollController.animateTo(
          currentScrollPosition,
          duration: const Duration(milliseconds: 100),
          curve: Curves.easeOut,
        );
      }
    });
  }

  void _handleMessageAdded(Map<String, dynamic> message) {
    setState(() {
      bool messageExists = displayedMessages.any((msg) =>
          msg['timeStamp'] == message['timeStamp'] &&
          msg['message'] == message['message']);

      if (!messageExists) {
        displayedMessages.insert(0, message);

        if (displayedMessages.length > messagesPerPage) {
          displayedMessages = displayedMessages.sublist(0, messagesPerPage);
        }
      }
    });
  }

  void goToBot() {
    WidgetsBinding.instance.addPostFrameCallback((_) {
      if (scrollController.hasClients) {
        scrollController.animateTo(
          0,
          duration: const Duration(milliseconds: 300),
          curve: Curves.fastOutSlowIn,
        );
      }
    });
  }

  void sendTextMessage() async {
    if (messController.text.isNotEmpty) {
      String text = messController.text;
      messController.clear();
      await messageSender.sendTextMessage(text);
    }
  }

  String formatTimestamp(Timestamp timestamp) {
    final messageTime = timestamp.toDate();
    return DateFormat('HH:mm dd/MM/yyyy').format(messageTime);
  }

  @override
  Widget build(BuildContext context) {
    final userId = authService.getCurrentUserId();

    return Scaffold(
      appBar: AppBar(
        title: Text(widget.nickname),
        backgroundColor: Colors.grey[900],
        actions: [
          IconButton(
            icon: Icon(Icons.call_outlined),
            onPressed: (){
              print("On develop Call");
            },
          ),
          IconButton(
            icon: Icon(Icons.videocam_outlined),
            onPressed: (){
              print("On develop VideoCall");
            },
          )
        ],
      ),
      body: Column(
        children: [
          Expanded(
            child: MessageList(
              displayedMessages: displayedMessages,
              allMessages: allMessages,
              scrollController: scrollController,
              isLoadingMore: isLoadingMore,
              formatTimestamp: formatTimestamp,
            ),
          ),
          StreamBuilder<bool>(
            stream: chatService.isBlockedHimStream(userId, widget.friendId),
            builder: (context, snapshot) {
              bool amIBlockedThisUser = snapshot.data ?? false;

              if (amIBlockedThisUser) {
                return Container(
                  padding: const EdgeInsets.all(16.0),
                  color: Colors.yellow[100],
                  child: Row(
                    mainAxisAlignment: MainAxisAlignment.spaceBetween,
                    children: [
                      Text(
                        "You have blocked this user",
                        style: TextStyle(
                          color: Colors.black87,
                          fontWeight: FontWeight.bold,
                        ),
                      ),
                      ElevatedButton(
                        onPressed: () {
                          chatService.blockActionUserForFriend(userId, widget.friendId);
                        },
                        child: Text("Unblock"),
                        style: ElevatedButton.styleFrom(
                          backgroundColor: Colors.blue,
                          foregroundColor: Colors.white,
                        ),
                      ),
                    ],
                  ),
                );
              }

              // If not blocked by current user, show input or blocked message
              if (!isBlocked) {
                return UserInput(
                  messController: messController,
                  focusNode: focusNode,
                  friendId: widget.friendId,
                  onMessageSent: goToBot,
                  sendTextMessage: sendTextMessage,
                  sendImageMessage: messageSender.sendImageMessage,
                  sendVideoMessage: messageSender.sendVideoMessage,
                  sendFileMessage: messageSender.sendFileMessage,
                );
              } else {
                return Container(
                  padding: const EdgeInsets.all(16.0),
                  child: Text(
                    "You have been blocked by your friend and cannot send messages.",
                    style: TextStyle(
                      color: Colors.red[900],
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                );
              }
            },
          ),
        ],
      ),
    );
  }

  Widget MessageList({
    required List<Map<String, dynamic>> displayedMessages,
    required List<Map<String, dynamic>> allMessages,
    required ScrollController scrollController,
    required bool isLoadingMore,
    required String Function(Timestamp) formatTimestamp,
  }) {
    String userId = authService.getCurrentUserId();

    return ListView.builder(
      controller: scrollController,
      reverse: true,
      itemCount: displayedMessages.length +
          (displayedMessages.length < allMessages.length ? 1 : 0),
      itemBuilder: (context, index) {
        if (index == displayedMessages.length) {
          return Container(
            padding: EdgeInsets.all(16),
            alignment: Alignment.center,
            child: isLoadingMore ? CircularProgressIndicator() : SizedBox.shrink(),
          );
        }

        Map<String, dynamic> data = displayedMessages[index];
        Timestamp currentTimestamp = data["timeStamp"];

        bool showTimestamp = index == displayedMessages.length - 1;
        if (!showTimestamp && index < displayedMessages.length - 1) {
          Timestamp nextTimestamp = displayedMessages[index + 1]["timeStamp"];
          showTimestamp = currentTimestamp
              .toDate()
              .difference(nextTimestamp.toDate())
              .inHours >
              3;
        }

        String deliverStatus = '';
        if(index ==0){
          if(data['isRead']== true){
            deliverStatus = 'Seen';
          }else if(data['isNoti_isDeliver']==true){
            deliverStatus = "Received";
          }else{
            deliverStatus = "Delivered";
          }
        }


        return Column(
          children: [
            MessBoxWithData(data, showTimestamp, formatTimestamp),
            if (index == 0 && data['senderId'] == userId) ...[
              Padding(
                padding: const EdgeInsets.only(right: 25.0),
                child: Align(
                  alignment: Alignment.centerRight,
                  child: Text(
                    deliverStatus,
                    style: TextStyle(
                      color: Colors.grey,
                      fontSize: 14,
                      fontStyle: FontStyle.italic,
                    ),
                  ),
                ),
              ),
              SizedBox(height: 10),
            ],
            if(index == 0 && data['senderId'] != userId)
              SizedBox(height: 10,)
          ],
        );
      },
    );
  }


  Widget MessBoxWithData(Map<String, dynamic> data, bool showTimestamp,
      String Function(Timestamp) formatTimestamp) {
    bool isMyMess = data['senderId'] == authService.getCurrentUserId();
    String currentUserId = authService.getCurrentUserId();
    var alignment = isMyMess ? Alignment.centerRight : Alignment.centerLeft;
    var messageColor = isMyMess ? Colors.blue : Colors.grey;
    double screenWidth = MediaQuery.of(context).size.width;

    List<String> deletedBy = List<String>.from(data['deletedBy'] ?? []);
    if (deletedBy.contains(currentUserId)) {
      return SizedBox.shrink();
    }

    List<String> likes = List<String>.from(data['likes'] ?? []);
    bool hasLikes = likes.isNotEmpty;
    bool isLikedByCurrentUser = likes.contains(currentUserId);

    void showOptionsMenu(BuildContext context) {
      Timestamp messageTime = data['timeStamp'];
      DateTime now = DateTime.now();
      Duration difference = now.difference(messageTime.toDate());
      bool isUndoable = difference.inMinutes <= 15;
      showModalBottomSheet(
        context: context,
        builder: (BuildContext context) {
          return Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              ListTile(
                leading: Icon(
                  Icons.favorite,
                  color: isLikedByCurrentUser ? Colors.red : null,
                ),
                title: Text(isLikedByCurrentUser ? "Unlike Message" : "Like Message"),
                onTap: () {
                  Navigator.pop(context);
                  chatService.toggleMessageLike(currentUserId, widget.friendId, data['id']);
                },
              ),
              ListTile(
                leading: Icon(Icons.delete),
                title: Text("Delete Message"),
                onTap: () {
                  Navigator.pop(context);
                  chatService.deleteMessage(currentUserId, widget.friendId, data['id']);
                },
              ),
              if (isMyMess && isUndoable)
                ListTile(
                  leading: Icon(Icons.undo),
                  title: Text("Undo Send"),
                  onTap: () {
                    Navigator.pop(context);
                    chatService.undoSentMessage(currentUserId, widget.friendId, data['timeStamp']);
                  },
                ),
              if (data["messType"] == null || data["messType"] == "text")
                ListTile(
                  leading: Icon(Icons.copy),
                  title: Text("Copy"),
                  onTap: () {
                    Navigator.pop(context);
                    Clipboard.setData(ClipboardData(text: data["message"] ?? ''));
                  },
                ),
              ListTile(
                leading: Icon(Icons.check),
                title: Text("Check"),
                onTap: () {
                  Navigator.pop(context);
                  print("data : $data");
                },
              )
            ],
          );
        },
      );
    }

    return Align(
      alignment: alignment,
      child: Column(
        crossAxisAlignment:
        isMyMess ? CrossAxisAlignment.end : CrossAxisAlignment.start,
        children: [
          if (showTimestamp)
            Padding(
              padding: const EdgeInsets.symmetric(vertical: 5.0),
              child: Center(
                child: Text(
                  formatTimestamp(data["timeStamp"]),
                  style: TextStyle(
                    color: Colors.grey,
                    fontSize: 14,
                    fontWeight: FontWeight.bold,
                  ),
                ),
              ),
            ),
          Stack(
            clipBehavior: Clip.none,
            children: [
              GestureDetector(
                onLongPress: () => showOptionsMenu(context),
                child: Container(
                  decoration: (data["messType"] == "image" ||
                      data["messType"] == "video" ||
                      data["messType"] == "holder")
                      ? null
                      : BoxDecoration(
                    color: messageColor,
                    borderRadius: BorderRadius.circular(12),
                  ),
                  padding: (data["messType"] == "image" ||
                      data["messType"] == "video" ||
                      data["messType"] == "holder")
                      ? null
                      : EdgeInsets.all(16),
                  margin: EdgeInsets.symmetric(vertical: 5, horizontal: 25),
                  child: ConstrainedBox(
                    constraints: BoxConstraints(maxWidth: 3 / 4 * screenWidth),
                    child: data["messType"] == "image"
                        ? ImageWithPlaceholder(
                      imageUrl: data["message"] ?? '',
                      fit: BoxFit.contain,
                    )
                        : data["messType"] == "video"
                        ? VideoPlayerWidget(videoUrl: data["message"] ?? '')
                        : data["messType"] == "text"
                        ? RichText(
                      text: replaceEmoticons(data["message"] ?? ''),
                    )
                        : Container(),
                  ),
                ),
              ),
              // Only show heart icon if message has likes
              if (hasLikes)
                Positioned(
                  bottom: -10,
                  left: isMyMess ? 10 : null,
                  right: isMyMess ? null : 10,
                  child: Stack(
                    alignment: Alignment.center,
                    children: [
                      Container(
                        width: 28,
                        height: 28,
                        decoration: BoxDecoration(
                          color: Colors.black,
                          borderRadius: BorderRadius.circular(14),
                        ),
                      ),
                      Icon(
                        isLikedByCurrentUser ? Icons.favorite : Icons.favorite_border,
                        color: Colors.red,
                        size: 20,
                      ),
                    ],
                  ),
                ),
            ],
          ),
        ],
      ),
    );
  }

  @override
  void dispose() {
    _messageSubscription?.cancel();
    scrollController.removeListener(_scrollListener);
    scrollController.dispose();
    focusNode.dispose();
    messController.dispose();
    super.dispose();
  }
}
