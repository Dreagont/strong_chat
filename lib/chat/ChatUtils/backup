import 'package:emoji_picker_flutter/emoji_picker_flutter.dart';
import 'package:flutter/material.dart';
import 'package:flutter/foundation.dart' show kIsWeb;
import 'package:flutter/services.dart';
import 'package:provider/provider.dart';
import '../../services/AuthService.dart';
import '../../services/FireStoreService.dart';
import '../../services/StorageService.dart';
import 'package:strong_chat/pages/ChangeTheme.dart';

class UserInput extends StatefulWidget {
  final TextEditingController messController;
  final FocusNode focusNode;
  final String friendId;
  final VoidCallback onMessageSent;
  final VoidCallback sendTextMessage;
  final VoidCallback sendImageMessage;
  final VoidCallback sendVideoMessage;
  final VoidCallback sendFileMessage;

  UserInput({
    required this.messController,
    required this.focusNode,
    required this.friendId,
    required this.onMessageSent,
    required this.sendTextMessage,
    required this.sendImageMessage,
    required this.sendVideoMessage,
    required this.sendFileMessage,
  });

  @override
  _UserInputState createState() => _UserInputState();
}

class _UserInputState extends State<UserInput> {
  bool isEmojiVisible = false;
  final FocusNode _emojiPickerFocus = FocusNode();

  final FireStoreService chatService = FireStoreService();
  final AuthService authService = AuthService();
  final StorageService storageService = StorageService();

  void _handleKeyEvent(RawKeyEvent event) {
    if (event is RawKeyDownEvent) {
      if (event.logicalKey == LogicalKeyboardKey.enter) {
        if (event.isShiftPressed) {
        } else {
          widget.sendTextMessage();
        }
      }
    }
  }

  void onEmojiSelected(Category? category, Emoji emoji) {
    widget.messController.text = widget.messController.text + emoji.emoji;
  }

  @override
  void dispose() {
    _emojiPickerFocus.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final themeProvider = Provider.of<ThemeProvider>(context);
    final color = themeProvider.themeMode == ThemeMode.dark ? Colors.white : Colors.grey;
    final backgroundColor = themeProvider.themeMode == ThemeMode.dark ? Colors.grey[900] : Colors.white;

    return Container(
      color: backgroundColor,
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          Visibility(
            visible: isEmojiVisible,
            child: SizedBox(
              height: 250,
              child: Focus(
                focusNode: _emojiPickerFocus,
                child: EmojiPicker(
                  onEmojiSelected: (category, emoji) => onEmojiSelected(category, emoji),
                  config: Config(
                    columns: 7,
                    emojiSizeMax: 32,
                    verticalSpacing: 0,
                    horizontalSpacing: 0,
                    initCategory: Category.RECENT,
                    bgColor: backgroundColor!,
                    indicatorColor: Colors.blue,
                    iconColor: color,
                    iconColorSelected: Colors.blue,
                    backspaceColor: color,
                    skinToneDialogBgColor: Colors.white,
                    skinToneIndicatorColor: Colors.grey,
                    enableSkinTones: true,
                    recentsLimit: 28,
                    noRecents: const Text('No Recent'),
                    loadingIndicator: const SizedBox.shrink(),
                    tabIndicatorAnimDuration: kTabScrollDuration,
                    categoryIcons: const CategoryIcons(),
                    buttonMode: ButtonMode.MATERIAL,
                  ),
                ),
              ),
            ),
          ),
          Container(
            decoration: BoxDecoration(
              color: backgroundColor,
              border: Border(
                top: BorderSide(
                  color: Colors.grey.withOpacity(0.2),
                ),
              ),
            ),
            child: Row(
              crossAxisAlignment: CrossAxisAlignment.end,
              children: [
                IconButton(
                  color: color,
                  icon: const Icon(Icons.attach_file),
                  onPressed: () => showMediaOptions(context),
                ),
                IconButton(
                  color: color,
                  icon: Icon(isEmojiVisible ? Icons.keyboard : Icons.emoji_emotions),
                  onPressed: () {
                    setState(() {
                      isEmojiVisible = !isEmojiVisible;
                    });
                    if (isEmojiVisible) {
                      FocusScope.of(context).requestFocus(_emojiPickerFocus);
                      widget.focusNode.unfocus();
                    } else {
                      FocusScope.of(context).requestFocus(widget.focusNode);
                    }
                  },
                ),
                Expanded(
                  child: Padding(
                    padding: const EdgeInsets.symmetric(vertical: 8.0),
                    child: TextFormField(
                      controller: widget.messController,
                      focusNode: widget.focusNode,
                      maxLines: 5,
                      minLines: 1,
                      textInputAction: TextInputAction.newline,
                      keyboardType: TextInputType.multiline,
                      onTap: () {
                        if (isEmojiVisible) {
                          setState(() {
                            isEmojiVisible = false;
                          });
                        }
                      },
                      decoration: const InputDecoration(
                        hintText: "Type your message",
                        border: InputBorder.none,
                        contentPadding: EdgeInsets.symmetric(horizontal: 16, vertical: 8),
                        isDense: true,
                      ),
                    ),
                  ),
                ),
                IconButton(
                  color: color,
                  onPressed: widget.sendTextMessage,
                  icon: const Icon(Icons.send),
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }

  void showMediaOptions(BuildContext context) {
    showModalBottomSheet(
      context: context,
      builder: (BuildContext context) {
        return SafeArea(
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              _buildMediaOption(
                context,
                Icons.image,
                'Image',
                widget.sendImageMessage,
              ),
              _buildMediaOption(
                context,
                Icons.video_library,
                'Video',
                widget.sendVideoMessage,
              ),
              _buildMediaOption(
                context,
                Icons.insert_drive_file,
                'File',
                widget.sendFileMessage,
              ),
            ],
          ),
        );
      },
    );
  }

  Widget _buildMediaOption(
      BuildContext context,
      IconData icon,
      String title,
      VoidCallback onTap,
      ) {
    return ListTile(
      leading: Icon(icon),
      title: Text(title),
      onTap: () {
        Navigator.pop(context);
        onTap();
      },
    );
  }
}
